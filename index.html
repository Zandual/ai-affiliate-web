<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <!-- Cloudflare Pages needs a correct base. Keep this as "/" since you fixed base href earlier. -->
    <base href="/" />

    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>AI Affiliate</title>

    <!--
      Expo / react-native-web reset + a little extra styling.
      IMPORTANT: #root must exist and your AppEntry JS must mount into it.
    -->
    <style id="expo-reset">
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: system-ui, sans-serif;
      }

      /* Your app uses a full-height root container */
      #root {
        display: flex;
        height: 100%;
        flex: 1;
        position: relative; /* so z-index layering behaves */
        z-index: 1;         /* keep app above the background canvas */
      }

      /*
        If you keep overflow hidden, long lists won't scroll.
        Better default: allow scrolling. Your app can still manage scroll itself.
      */
      body {
        overflow: auto;
        background: radial-gradient(circle at 20% 20%, rgba(0,150,255,.10), transparent 45%),
                    radial-gradient(circle at 80% 30%, rgba(140,0,255,.08), transparent 50%),
                    radial-gradient(circle at 50% 90%, rgba(0,255,180,.06), transparent 45%),
                    #ffffff;
      }

      /*
        Background canvas (non-interactive visual layer)
        pointer-events: none means it will NEVER block clicks/taps on your UI.
      */
      #bg {
        position: fixed;
        inset: 0;
        width: 100vw;
        height: 100vh;
        z-index: 0;
        pointer-events: none;
      }
    </style>
  </head>

  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>

    <!-- Visual background layer -->
    <canvas id="bg" aria-hidden="true"></canvas>

    <!-- Expo app mounts here -->
    <div id="root"></div>

    <!--
      1) AppEntry must load (this is your built bundle).
      Use defer so it loads after HTML is parsed, without blocking rendering.
    -->
    <script src="./AppEntry-ff4ae59a90a1b1b6314d086b5393f432.js" defer></script>

    <!--
      2) Small enhancement script:
         - draws the animated background
         - adds subtle animations to product cards AFTER they appear
      Use defer so it runs after parsing and alongside AppEntry loading.
    -->
    <script defer>
      (function () {
        /***********************
         * PART A: Background canvas animation
         ************************/
        const canvas = document.getElementById("bg");
        const ctx = canvas.getContext("2d");

        const DPR = Math.max(1, Math.floor(window.devicePixelRatio || 1));
        let w = 0, h = 0;

        function resize() {
          w = Math.floor(window.innerWidth);
          h = Math.floor(window.innerHeight);
          canvas.width = w * DPR;
          canvas.height = h * DPR;
          canvas.style.width = w + "px";
          canvas.style.height = h + "px";
          ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
        }

        window.addEventListener("resize", resize);
        resize();

        const mouse = { x: w * 0.5, y: h * 0.5 };
        window.addEventListener("mousemove", (e) => {
          mouse.x = e.clientX;
          mouse.y = e.clientY;
        });

        // Lightweight particle field (kept modest so it doesn't hurt performance)
        const N = 60;
        const pts = Array.from({ length: N }, () => ({
          x: Math.random() * w,
          y: Math.random() * h,
          vx: (Math.random() - 0.5) * 0.35,
          vy: (Math.random() - 0.5) * 0.35,
          r: 1.2 + Math.random() * 1.8,
        }));

        function tick() {
          ctx.clearRect(0, 0, w, h);

          // dots
          for (const p of pts) {
            p.x += p.vx;
            p.y += p.vy;

            // gentle mouse attraction
            const dx = mouse.x - p.x;
            const dy = mouse.y - p.y;
            const d2 = dx * dx + dy * dy;
            if (d2 < 180 * 180) {
              p.vx += dx * 0.00001;
              p.vy += dy * 0.00001;
            }

            // wrap
            if (p.x < -20) p.x = w + 20;
            if (p.x > w + 20) p.x = -20;
            if (p.y < -20) p.y = h + 20;
            if (p.y > h + 20) p.y = -20;

            ctx.beginPath();
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fillStyle = "rgba(0,0,0,0.10)";
            ctx.fill();
          }

          // lines
          for (let i = 0; i < pts.length; i++) {
            for (let j = i + 1; j < pts.length; j++) {
              const a = pts[i], b = pts[j];
              const dx = a.x - b.x, dy = a.y - b.y;
              const d = Math.hypot(dx, dy);
              if (d < 140) {
                ctx.globalAlpha = (1 - d / 140) * 0.16;
                ctx.beginPath();
                ctx.moveTo(a.x, a.y);
                ctx.lineTo(b.x, b.y);
                ctx.strokeStyle = "rgba(0,0,0,0.30)";
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.globalAlpha = 1;
              }
            }
          }

          requestAnimationFrame(tick);
        }
        tick();

        /***********************
         * PART B: UI micro-interactions
         * Your app is rendered by AppEntry, so cards may appear AFTER page load.
         * We "watch" the DOM and animate cards when they show up.
         ************************/
        function enhanceCards(root) {
          // Try multiple selectors because your UI might use different class names.
          const cards = root.querySelectorAll(".product-card, .card");
          cards.forEach((card) => {
            // Prevent re-applying on the same element
            if (card.dataset.enhanced === "1") return;
            card.dataset.enhanced = "1";

            card.style.opacity = "0";
            card.style.transform = "translateY(12px)";
            card.style.transition = "opacity 500ms ease, transform 500ms ease, box-shadow 200ms ease";

            // Let layout happen first, then animate in
            requestAnimationFrame(() => {
              card.style.opacity = "1";
              card.style.transform = "translateY(0)";
            });

            card.addEventListener("mouseenter", () => {
              card.style.boxShadow = "0 10px 30px rgba(0,0,0,0.10)";
            });
            card.addEventListener("mouseleave", () => {
              card.style.boxShadow = "none";
            });
          });
        }

        // Run once after DOM is ready
        document.addEventListener("DOMContentLoaded", () => {
          enhanceCards(document);
        });

        // Observe #root for new content (React renders after load)
        const rootEl = document.getElementById("root");
        if (rootEl) {
          const observer = new MutationObserver(() => enhanceCards(rootEl));
          observer.observe(rootEl, { childList: true, subtree: true });
        }
      })();
    </script>
  </body>
</html>
